{"version":3,"sources":["Components/Card.js","Components/Images.js","images/img1.svg","images/img2.svg","images/img3.svg","images/img4.svg","images/img5.svg","images/img6.svg","images/img7.svg","images/img8.svg","Components/MemoryGame.js","App.js","reportWebVitals.js","index.js"],"names":["Card","id","image","game","flippedCount","setFlippedCount","flippedIndexes","setFlippedIndexes","useState","flipped","set","useSpring","opacity","transform","config","mass","tension","friction","useEffect","indexOf","setTimeout","state","onClick","newIndexes","push","div","className","style","interpolate","o","t","background","Images","MemoryGame","options","setOptions","setGame","newGame","i","firstOption","imageId","secondOption","shuffledGame","sort","Math","random","some","card","length","map","index","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.74f940ac.chunk.js","sourcesContent":["// Importing React Hooks\r\nimport React, { useState, useEffect } from \"react\";\r\n// Importing React spring animation\r\nimport { useSpring, animated as a } from \"react-spring\";\r\n\r\n// This is the Card setup\r\n// Each card will have a flipped value on the individual component. This value works \r\n// with the useSpring hook below it to implement the flipping card animation.\r\nfunction Card({\r\n    id,\r\n    image, \r\n    game,\r\n    flippedCount,\r\n    setFlippedCount,\r\n    flippedIndexes,\r\n    setFlippedIndexes,\r\n  }) {\r\n    // Setting the React spring Flip card animation\r\n    const [flipped, set] = useState(false)\r\n    const {transform, opacity} = useSpring({\r\n    opacity: flipped ? 1 : 0,\r\n    transform: `perspective(600px) rotateX(${flipped ? 180 : 0}deg)`,\r\n    config: {mass: 5, tension: 500, friction: 80},\r\n    })\r\n\r\n    // More match logic in Effect Hook\r\n    useEffect(() => {\r\n      // If the third value in flippedIndexes is true we don’t have a match\r\n      // Both conditions will add to the flippedCount and empty the flippedIndexes array\r\n      if (flippedIndexes[2] === true && flippedIndexes.indexOf(id) > -1) {\r\n        // Using a setTimeout for 1 sec. to add a delay to cards flipping back.\r\n        setTimeout(() => {\r\n          set(state => !state)\r\n          setFlippedCount(flippedCount + 1)\r\n          setFlippedIndexes([])\r\n        }, 1000)\r\n      } else if (flippedIndexes[2] === false && id === 0) {\r\n        setFlippedCount(flippedCount + 1)\r\n        setFlippedIndexes([])\r\n      }\r\n    }, [flippedIndexes]) // Pass an array as an optional second argument to tell React \r\n    // to skip applying an effect if certain values haven’t changed between re-renders.\r\n\r\n    // The click logic. Check if a card is allowed to be flipped.\r\n    const onCardClick = () => {\r\n      // The flippedCount variable will increase by one each time either the first guess is flipped, the \r\n      // second guess is flipped or the two cards match or don't match.\r\n      if (!game[id].flipped && flippedCount % 3 === 0) {\r\n        set(state => !state)\r\n        setFlippedCount(flippedCount + 1)\r\n        const newIndexes = [...flippedIndexes]\r\n        newIndexes.push(id)\r\n        setFlippedIndexes(newIndexes)\r\n      } else if (\r\n        flippedCount % 3 === 1 &&\r\n        !game[id].flipped &&\r\n        flippedIndexes.indexOf(id) < 0\r\n      ) {\r\n        set(state => !state)\r\n        setFlippedCount(flippedCount + 1)\r\n        const newIndexes = [...flippedIndexes]\r\n        newIndexes.push(id)\r\n        setFlippedIndexes(newIndexes)\r\n      }\r\n    }\r\n     // Returning styles for the front and back of each card. We will apply the same background image \r\n     // to the back of every card, url is defined in the css and background images from the Images array to the front.\r\n    return (\r\n      <div onClick={onCardClick}>      \r\n            <a.div\r\n              className=\"c back\"\r\n              style={{\r\n                opacity: opacity.interpolate(o => 1 - o),\r\n                transform,\r\n              }}\r\n            />\r\n            <a.div\r\n              className=\"c front\"\r\n              style={{\r\n                opacity,\r\n                transform: transform.interpolate(t => `${t} rotateX(180deg)`),\r\n                background: `url(${image})` \r\n              }}\r\n            />\r\n      </div>\r\n      )\r\n}\r\n\r\nexport default Card;","// Importing all the images\r\nimport img1 from \"../images/img1.svg\";\r\nimport img2 from \"../images/img2.svg\";\r\nimport img3 from \"../images/img3.svg\";\r\nimport img4 from \"../images/img4.svg\";\r\nimport img5 from \"../images/img5.svg\";\r\nimport img6 from \"../images/img6.svg\";\r\nimport img7 from \"../images/img7.svg\";\r\nimport img8 from \"../images/img8.svg\";\r\n\r\n// Creating an image array\r\nconst Images = [img1, img2, img3, img4, img5, img6, img7, img8,]\r\n\r\nexport default Images;\r\n\r\n// Icons made by Pixel perfect, https://www.flaticon.com/authors/pixel-perfect, from https://www.flaticon.com/","export default __webpack_public_path__ + \"static/media/img1.e993a073.svg\";","export default __webpack_public_path__ + \"static/media/img2.54802bad.svg\";","export default __webpack_public_path__ + \"static/media/img3.67ff6441.svg\";","export default __webpack_public_path__ + \"static/media/img4.cd993bce.svg\";","export default __webpack_public_path__ + \"static/media/img5.74273b14.svg\";","export default __webpack_public_path__ + \"static/media/img6.bead8327.svg\";","export default __webpack_public_path__ + \"static/media/img7.e65b3231.svg\";","export default __webpack_public_path__ + \"static/media/img8.1c615606.svg\";","// Importing Images and Card components and React Hooks\r\nimport Card from './Card';\r\nimport React, { useState, useEffect } from \"react\";\r\nimport Images from \"./Images\";\r\n\r\n\r\n// This is the game logic\r\nfunction MemoryGame({options, setOptions}) {\r\n    // Declaring state variables\r\n    const [game, setGame] = useState([])\r\n    const [flippedCount, setFlippedCount] = useState(0)\r\n    const [flippedIndexes, setFlippedIndexes] = useState([])\r\n\r\n    // The Effect Hook lets you perform side effects in function components\r\n    // The useEffect hook runs here when the component renders and randomly \r\n    // assigns options / 2 images out to all the cards.\r\n    useEffect(() => {\r\n        const newGame = []\r\n        // Looping through the array of options which are the images\r\n        // There are 8 images and we have set the options to 16 so every image is duplicated\r\n        // The imageId will be the same for matching images\r\n        // The id will be different for each image\r\n        for (let i = 0; i < options / 2; i++) {\r\n          const firstOption = {\r\n            id: 2 * i,\r\n            imageId: i,\r\n            image: Images[i],\r\n            flipped: false,\r\n          }\r\n          const secondOption = {\r\n            id: 2 * i + 1,\r\n            imageId: i,\r\n            image: Images[i],\r\n            flipped: false,\r\n          }\r\n          // Pushing the options to the newGame array\r\n          newGame.push(firstOption)\r\n          newGame.push(secondOption)\r\n        }\r\n        \r\n        // Shuffle the array with sort() and Math.random() to mix up the images/cards\r\n        const shuffledGame = newGame.sort(() => Math.random() - 0.5)\r\n        // Setting the game state to the shuffled game\r\n        setGame(shuffledGame)\r\n      }, []) // Passing an empty array so the props and state inside the effect will always have their initial values\r\n      \r\n      // Here we use the Effect hook to set options to null when the game is finished\r\n      // We will then return to initial state after 1 sec. as set in setTimeout\r\n      useEffect(() => {\r\n        const finished = !game.some(card => !card.flipped)\r\n        if (finished && game.length > 0) {\r\n            setTimeout(() => {\r\n                setOptions(null)\r\n            }, 1000)\r\n        }\r\n      }, [game]) // Pass an array as an optional second argument to tell React \r\n                // to skip applying an effect if certain values haven’t changed between re-renders.\r\n      \r\n      // If two cards have been flipped\r\n      if (flippedIndexes.length === 2) {\r\n        // Declare it a match when both flipped indexes have the same imageId\r\n        const match = game[flippedIndexes[0]].imageId === game[flippedIndexes[1]].imageId\r\n        // If they match \r\n        if (match) {\r\n        // We clone the game board to update the flipped values of those cards in the game array\r\n          const newGame = [...game]\r\n          // Setting the flipped indexes to true\r\n          newGame[flippedIndexes[0]].flipped = true\r\n          newGame[flippedIndexes[1]].flipped = true\r\n          // And setting the game state to newGame\r\n          setGame(newGame)\r\n\r\n        // Then we update the game and set the third flippedIndexes value to be false, preventing a flip reset\r\n          const newIndexes = [...flippedIndexes]\r\n          newIndexes.push(false)\r\n          setFlippedIndexes(newIndexes)\r\n          // If not a match we leave the game board alone and add true to the flippedIndexes array,\r\n          // triggering a flip reset.\r\n        } else {\r\n          const newIndexes = [...flippedIndexes]\r\n          newIndexes.push(true)\r\n          setFlippedIndexes(newIndexes)\r\n        }\r\n      }\r\n        // This is what the function returns to the DOM\r\n        return (\r\n          <div id=\"cards\">\r\n            {/* Mapping the game array to render out the cards. Also passing down id, \r\n            image, game and both flipped hooks to each of the cards to use in the click handlers */}\r\n            {game.map((card, index) => (\r\n              <div className=\"card\" key={index}>\r\n                <Card\r\n                  id={index}\r\n                  image={card.image}\r\n                  game={game}\r\n                  flippedCount={flippedCount}\r\n                  setFlippedCount={setFlippedCount}\r\n                  flippedIndexes={flippedIndexes}\r\n                  setFlippedIndexes={setFlippedIndexes}\r\n                />\r\n              </div>\r\n            ))}\r\n          </div>\r\n        )\r\n      \r\n}\r\n\r\nexport default MemoryGame;","// Importing css file, component and React Hook\nimport './App.css';\nimport MemoryGame from './Components/MemoryGame';\nimport React, { useState } from \"react\";\n\n// In this function we pass in all components and then a function in index.js will render it to the DOM.\nfunction App() {\n  // Declare the options state variable\n  const [options, setOptions] = useState(null)\n\n  // This is what the function returns to the DOM\n  return (\n    <div className=\"App\">\n      <div className=\"navbar\">\n            <div>Memory game</div>\n      </div>\n      \n      {options ? (\n        <MemoryGame\n          options={options}\n          setOptions={setOptions}\n        />\n      ) : (\n        <button className=\"start-btn\" onClick={() => setOptions(16)}>Start a new game!</button>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}